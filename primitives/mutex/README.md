# Примитив синхронизации: Mutex

## Что такое Mutex?

Mutex (Mutual Exclusion Lock) — это механизм, позволяющий ограничить одновременный доступ к разделяемым ресурсам. При использовании мьютекса гарантируется, что в критической секции кода в один момент времени выполняется не более одного потока (горутины). Это особенно важно при работе с общими переменными или ресурсами, которые могут быть изменены из нескольких потоков.

## Как работает реализация на Go?

В реализации мьютекса:
- **Состояние блокировки** представлено целочисленным полем `state` (тип `int32`), где значение `0` означает, что мьютекс свободен, а `1` – что он захвачен.
- Для установки блокировки используется атомарная операция сравнения и обмена: `atomic.CompareAndSwapInt32`. При попытке захватить мьютекс, горутина пытается сменить состояние с `0` на `1`.
- Если попытка неудачна (то есть другой поток уже захватил мьютекс), горутина не простаивает в жёстком цикле, а вызывает `runtime.Gosched()`, позволяя планировщику переключиться на выполнение других горутин.

Обратите внимание, что в стандартной реализации `sync.Mutex` используются более сложные механизмы (например, механизм ожидания, основанный на системных вызовах), чтобы избежать чрезмерного расхода ресурсов в условиях высокой конкуренции. Моя реализация демонстрирует базовый принцип работы с использованием атомарных операций и активного ожидания.

## Пример использования

```go
package main

import (
	"fmt"
	"runtime"
	"time"

	"primitives/mutex"
)

func main() {
	var m mutex.Mutex
	counter := 0

	// Запускаем 100 горутин, которые увеличивают общий счетчик
	for i := 0; i < 100; i++ {
		go func() {
			m.Lock()
			// Критическая секция: безопасное изменение разделяемой переменной
			counter++
			m.Unlock()
		}()
	}

	// Ждём завершения горутин (упрощённый способ — через sleep, для демонстрации)
	time.Sleep(100 * time.Millisecond)

	// Вывод результата
	fmt.Printf("Итоговый счетчик: %d\n", counter)
	// Обратите внимание: при корректной работе мьютекса итоговый счетчик должен быть равен 100.
	
	// Вызов Gosched, чтобы завершить выполнение остальных горутин (если есть)
	runtime.Gosched()
}
