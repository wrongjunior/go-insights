# Пул горутин: глубокий анализ и реализация

## Введение

В Go создание горутин является чрезвычайно дешёвым и быстрым процессом, однако в некоторых сценариях бесконтрольное их создание может привести к чрезмерному использованию ресурсов (например, если задача требует высокой степени параллелизма или если входной поток заданий очень велик). Для решения таких проблем применяется **пул горутин** — паттерн, позволяющий ограничить максимальное количество одновременно работающих горутин, распределяя входящие задачи между фиксированным числом воркеров.

## Теоретические основы

### Зачем нужен пул горутин?

- **Контроль потребления ресурсов:** Ограничение количества одновременно работающих горутин позволяет избежать перегрузки ОС и расхода памяти.
- **Предсказуемость поведения:** Пул горутин даёт гарантии по количеству одновременно выполняемых заданий, что особенно важно при работе с внешними ресурсами (например, при обращении к базе данных или сетевым API).
- **Оптимизация планировщика:** При большом количестве горутин планировщик Go может тратить значительное время на переключение между ними, а пул позволяет снизить этот оверхед.

### Принципы реализации

В предлагаемой реализации пул горутин использует следующие ключевые идеи:

1. **Буферизированный канал заданий:** Все поступающие задачи (функции без параметров) помещаются в канал, который служит очередью ожидания.
2. **Фиксированное количество воркеров:** При создании пула запускается определённое число горутин, каждая из которых непрерывно слушает канал заданий.
3. **Синхронизация с помощью WaitGroup:** Для гарантированного завершения всех поставленных задач используется встроенный механизм ожидания (sync.WaitGroup). Перед постановкой задачи в очередь происходит увеличение счётчика, а по завершении задачи – уменьшение.
4. **Границы жизненного цикла:** После завершения работы все воркеры корректно завершаются посредством закрытия канала заданий.

## Внутренние механизмы

- **Диспетчеризация заданий:** При вызове метода `Submit` задача добавляется в канал. Воркер, ожидающий задачу через оператор `range`, получает её и выполняет.
- **Гарантия завершения:** Метод `Shutdown` закрывает канал заданий, что приводит к выходу цикла в каждом воркере, и затем ждёт завершения всех задач посредством `WaitGroup`.

## Пример использования

```go
package main

import (
	"fmt"
	"time"

	"concurrency/goroutine_pool"
)

func main() {
	// Создаём пул с 5 воркерами и буфером для 20 заданий.
	pool := goroutine_pool.NewPool(5, 20)

	// Подаём 50 заданий для выполнения.
	for i := 0; i < 50; i++ {
		// Захватываем значение i локально, чтобы избежать проблем замыкания.
		taskID := i
		pool.Submit(func() {
			// Симуляция работы: каждая задача спит случайное время.
			fmt.Printf("Выполнение задачи #%d\n", taskID)
			time.Sleep(50 * time.Millisecond)
		})
	}

	// Завершаем пул: больше заданий не принимается, и ждём выполнения всех текущих.
	pool.Shutdown()
	fmt.Println("Все задачи выполнены, пул завершён.")
}
